/*--------------- 1ra Area: Codigo de Usuario -----------------------*/
//-------> importaciones, paquetes
package Models;
import java_cup.runtime.Symbol;


//------> Codigo para el parser,variables, metodos
parser code
{:
    public String result="";
    String temporal = "" ; 
    String temporal2="";
    String temporal3="";
    String temporalvalor="";
    String envget="false";
    String enviaset="false";
    String hereda="";
    String guardo="";
    String consulta="";
    String valorsigno="";
    String valoracceder="";
    String valoraccederid="";
    String serialcondicion="";
    String insertarvalores="";

    //Metodo al que se llama automaticamente ante algun error sintactico
    public void syntax_error(Symbol s)
    {        
        String lexema = s.value.toString();
        int fila = s.right;
        int columna = s.left;
        result +="\n!!!!!!! Error Sintactico Recuperado !!!!!!!\t\tLexema: "+lexema+"\t\tFila: "+fila+"\t\tColumna: "+columna;
        System.out.println("!!!!!!! Error Sintactico Recuperado !!!!!!!");
        System.out.println("\t\tLexema: "+lexema);
        System.out.println("\t\tFila: "+fila);
        System.out.println("\t\tColumna: "+columna);
        
       
        
    }

    //Metodo al que se llama en el momento en que ya no es posible una recuperacion de errores
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception
    {        
        String lexema = s.value.toString();
        int fila = s.right;
        int columna = s.left;
        result +="\n!!!!!!! Error Sintactico, Panic Mode !!!!!!!\t\tLexema: "+lexema+"\t\tFila: "+fila+"\t\tColumna: "+columna;
        System.out.println("!!!!!!! Error Sintactico, Panic Mode !!!!!!! ");
        System.out.println("\t\tLexema: "+lexema);
        System.out.println("\t\tFila: "+fila);
        System.out.println("\t\tColumna: "+columna);
     
    }
:}

//------> Codigo para las acciones gramaticales
action code
{:
:}


/*-------------NOTAS

OJO EN LAS PRODUCCIONES CICLO Y CONDICIONAL SE PUEDE VARIAR ENTRE 
INSTRUCCIONES1 Y CUERPITO ... SI PONGO INSTRUCCIONES1 HAY QUE FINALIZAR CADA INSTRUCCION CON UN -- 
Y SI LO REEMPLAZO POR CUERPITO SOLO FINALIZO CON -- EN EL FINAL
INSTRUCCIONES1 ME PERMITE HACER LAS OPERACIONES QUE QUIERA 
CUERPITO UNA 

FALTA INGRESAR RETORNOS 
-------------*/

/*--------------- 2da Area: Declaraciones -----------------------*/
//------> declaracion de terminales 
terminal function, procedure, boolean_type , int_type , float_type , char_type , string_type  ;
terminal parametro_entrada , parametro_salida , parametro_entada_salida , ciclo_for , ciclo_while , ciclo_repeat , condicional_if ;
terminal condicional_switch , condicional_until , then , sino  , end_if ,  caso ;
terminal  suma , resta , multiplicacion , division , potencia , menor  , mayor , comparacion , menor_igual ;
terminal mayor_igual ,  modulo , diferente , or , and , not ,  asignacion , parentesis_abierto ;
terminal parentesis_cerrado , llave_abierta , llave_cerrada , corchete_abierto , corchete_cerrado , coma , hasta , hacer  ;
terminal  down_to  , digito , letra , entero , numero , id , comilla_abierta , comilla_cerrada, end_for ;
terminal dos_puntos, end_while, lambda , imprimir , decimal  ;





//------> declaracion de no terminales   


non terminal S , INICIO, ARGUMENTOS , DEFVARS , CUERPITO , REFERENCIA , TIPODATO , VECTOR , OPERADOR_LOGICO, DEFVAR ;
non terminal  ELEMENTO,ELEMENTOS , MATRIZ, EXP_NUMERICA   , OPEMATES,  OPERADOR_RELACIONAL , EXP_INICIO , IMPRIMIR , VARIABLES ;
non terminal EXPRESION_REG, ARGUMENTO ,CONDICION11, INSTRUCCIONES1   ,OPERADOR_MATEMATICO ,CICLO , CONDICION, CONDICIONAL , VAR, VARS ;
 
start with S;



/*--------------- 3ra Area: Reglas Semanticas -----------------------*/
S ::= INICIO | INICIO S;

INICIO ::=   procedure id parentesis_abierto ARGUMENTO parentesis_cerrado DEFVARS llave_abierta INSTRUCCIONES1 llave_cerrada
            | procedure id parentesis_abierto  parentesis_cerrado DEFVARS llave_abierta INSTRUCCIONES1 llave_cerrada
            | procedure id parentesis_abierto  parentesis_cerrado  llave_abierta INSTRUCCIONES1 llave_cerrada
            | procedure id parentesis_abierto ARGUMENTO parentesis_cerrado  llave_abierta INSTRUCCIONES1 llave_cerrada
            | function id parentesis_abierto ARGUMENTO parentesis_cerrado DEFVARS llave_abierta INSTRUCCIONES1 llave_cerrada
            | function id parentesis_abierto ARGUMENTO parentesis_cerrado  llave_abierta INSTRUCCIONES1 llave_cerrada
            | function id parentesis_abierto  parentesis_cerrado DEFVARS llave_abierta INSTRUCCIONES1 llave_cerrada
            | function id parentesis_abierto  parentesis_cerrado  llave_abierta INSTRUCCIONES1 llave_cerrada ;

EXP_INICIO ::= id | letra ; 
EXP_NUMERICA ::= digito | entero | decimal ; 

ARGUMENTO ::= ARGUMENTOS | ARGUMENTOS ARGUMENTO ; 

ARGUMENTOS ::= REFERENCIA TIPODATO EXP_INICIO coma  
              | REFERENCIA TIPODATO EXP_INICIO 
              | REFERENCIA  TIPODATO VECTOR 
              | REFERENCIA  TIPODATO VECTOR  coma
              | REFERENCIA  TIPODATO  MATRIZ
              | REFERENCIA  TIPODATO  MATRIZ coma ;

REFERENCIA ::= parametro_entrada | parametro_salida | parametro_entada_salida ; 

ELEMENTO ::= ELEMENTOS | ELEMENTOS ELEMENTO ;

ELEMENTOS ::= EXP_NUMERICA coma  | EXP_NUMERICA |  comilla_abierta EXP_INICIO comilla_cerrada | comilla_abierta EXP_INICIO comilla_cerrada coma  | EXP_INICIO  coma ;

TIPODATO ::= int_type | char_type | float_type | boolean_type | string_type   ;



VECTOR ::=    EXP_INICIO corchete_abierto corchete_cerrado 
           |  EXP_INICIO corchete_abierto EXP_NUMERICA corchete_cerrado 
           |  EXP_INICIO corchete_abierto EXP_INICIO corchete_cerrado 
           |  EXP_INICIO corchete_abierto  corchete_cerrado asignacion llave_abierta ELEMENTO llave_cerrada ;
           
MATRIZ ::=     EXP_INICIO corchete_abierto corchete_cerrado  corchete_abierto corchete_cerrado 
            |  EXP_INICIO  corchete_abierto EXP_INICIO  corchete_cerrado  corchete_abierto EXP_INICIO corchete_cerrado 
            | EXP_INICIO  corchete_abierto EXP_NUMERICA  corchete_cerrado  corchete_abierto EXP_NUMERICA corchete_cerrado  
            | EXP_INICIO  corchete_abierto EXP_NUMERICA  corchete_cerrado  corchete_abierto EXP_INICIO corchete_cerrado
            |EXP_INICIO  corchete_abierto EXP_INICIO  corchete_cerrado  corchete_abierto EXP_NUMERICA corchete_cerrado ; 

DEFVARS  ::= DEFVAR| DEFVAR DEFVARS   ;

DEFVAR ::= TIPODATO VARS ;

VARS ::= VARS VAR |  VAR ; 

VAR ::= id | letra | id asignacion EXPRESION_REG| letra asignacion EXPRESION_REG | MATRIZ | VECTOR ;


EXPRESION_REG ::= digito | numero | entero | id | letra ;

OPERADOR_MATEMATICO ::= suma | resta | multiplicacion | division | potencia | modulo ;

OPERADOR_LOGICO ::= menor | mayor | comparacion | menor_igual |mayor_igual | diferente | not  ; 

OPERADOR_RELACIONAL ::= and | or | not ;

INSTRUCCIONES1 ::= lambda| CUERPITO INSTRUCCIONES1 ;

CUERPITO ::= CICLO | CONDICIONAL  | OPEMATES | IMPRIMIR | VARIABLES   ;

VARIABLES ::=  EXP_INICIO asignacion EXP_NUMERICA | EXP_INICIO asignacion EXP_INICIO
               |  EXP_INICIO asignacion  VECTOR
                 |   VECTOR ; 

IMPRIMIR ::= imprimir comilla_abierta id comilla_cerrada; 

CICLO ::= ciclo_for parentesis_abierto EXP_INICIO asignacion EXP_NUMERICA hasta EXPRESION_REG parentesis_cerrado hacer INSTRUCCIONES1 end_for | 
        ciclo_for parentesis_abierto EXP_INICIO asignacion EXP_INICIO hasta EXPRESION_REG parentesis_cerrado hacer INSTRUCCIONES1 end_for |
        ciclo_for parentesis_abierto EXP_INICIO asignacion EXP_NUMERICA down_to EXPRESION_REG parentesis_cerrado hacer INSTRUCCIONES1 end_for |
        ciclo_while parentesis_abierto CONDICION parentesis_cerrado hacer INSTRUCCIONES1 end_while |
        ciclo_repeat INSTRUCCIONES1 condicional_until parentesis_abierto CONDICION parentesis_cerrado ;

CONDICIONAL ::= condicional_if parentesis_abierto CONDICION11 parentesis_cerrado then INSTRUCCIONES1 end_if 
		|condicional_if parentesis_abierto CONDICION11 parentesis_cerrado then INSTRUCCIONES1 sino INSTRUCCIONES1 end_if 
		| condicional_switch id caso id dos_puntos INSTRUCCIONES1 caso
                |caso id INSTRUCCIONES1 ;

CONDICION11 ::= CONDICION | CONDICION CONDICION11 ; 

CONDICION ::=    parentesis_abierto EXPRESION_REG OPERADOR_LOGICO EXPRESION_REG parentesis_cerrado
              |  parentesis_abierto  VECTOR OPERADOR_LOGICO EXPRESION_REG parentesis_cerrado
              |  parentesis_abierto  EXPRESION_REG OPERADOR_LOGICO VECTOR parentesis_cerrado
              | OPERADOR_RELACIONAL ; 

//------> ASIGNAR ::= id asignacion EXPRESION_REG   ; 

OPEMATES ::= EXP_INICIO asignacion EXPRESION_REG OPERADOR_MATEMATICO EXPRESION_REG 
            | EXP_INICIO asignacion EXPRESION_REG OPERADOR_MATEMATICO EXPRESION_REG OPERADOR_MATEMATICO EXPRESION_REG 
            | EXP_INICIO asignacion EXPRESION_REG OPERADOR_MATEMATICO EXPRESION_REG OPERADOR_MATEMATICO EXPRESION_REG OPERADOR_MATEMATICO EXPRESION_REG ;
           
     
/*---------------
E ::= E suma T | E resta T | T  ;
T ::= T multiplicacion F | T division F | F ;
F ::= digito | numero | entero ;
-----------------------*/

 